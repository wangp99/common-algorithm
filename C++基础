1、 extern修饰变量、函数，如extern int a，说明要使用的该变量、函数定义在别的文件中，extern只能修饰全局变量，不能修饰局部变量，函数默认前面加了extern。如当要在2.cpp中使用定义在1.cpp文件
中的全局变量时，需要在2.cpp声明extern int a（不需要包含#include“1.cpp”），方可使用1.cpp中的全局变量a。如果1.cpp有头文件1.h，在1.h中声明全局变量extern int a，在1.cpp中定义int a=100，
如果2.cpp想要使用该变量，则只需#include<1.h>即可在2.cpp中使用a，不需要在2.cpp中添加声明语句extern int a。如果头文件中声明变量或函数为static，则该变量或函数的定义只能在该头文件中完成，
变量默认为0，如果想要在对应的cpp文件中再对头文件中声明的static变量或函数进行定义，就会报重复定义的错误。

2、static变量修饰全局变量，改变的是该全局变量的作用范围，限定该变量/函数只能作用在本文件内，extern默认为整个程序（包含多个文件）。static修饰局部变量，改变的是该变量的生命周期，退出函数
时该变量不销毁，程序结束才销毁，存储在静态区（全局变量、静态变量都存储在静态区（全局区））。静态局部变量只声明一次，一旦申请内存成功，不再接受重复申请，之后的再进行定义修改只是在修改
它的值。包含定义了static变量的头文件即可使用该变量（无须声明），可以将包含了头文件的cpp文件看成与头文件在同一个文件，这样static变量就可以看成在一个文件范围内。

3、c++输入输出的处理函数
（1） cin是最常见的，如cin>>a>>b  
注意:>> 是会过滤掉不可见字符（如 空格 回车，TAB 换行等）
当 cin>> 从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，cin>> 会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待。但是如果读取成功，
字符最后的分隔符是残留在缓冲区的，cin>> 不做处理。

cin 遇空格或换行，会停止识别，当接受一个字符串，遇“空格”、“TAB”、“回车”都结束

 由于cin在遇到空格/tab时，就会停止读取，所以如果我在第一次输入时，利用空格隔开两个字符串，那么cin在第一次取的时候，只会读取前一个字符串，到空格结束，此时缓冲区还保留着前面输入的第二个
 字符串，那么第二次cin就会直接从缓冲区取残留数据，而不会请求输入。
当然对于以上的情况，也有解决的方案，那就是在第二次调用cin>>str之前通过cin.sync()来清空输入缓冲区

(2)cin.get()

输入结束条件：Enter键

对结束符处理：不丢弃缓冲区中的Enter

若要读取单个字符，直接cin.get(char ch)或ch=cin.get()即可

cin.get()的返回值是int类型，成功：读取字符的ASCII码值，遇到文件结束符时，返回EOF，即-1，Windows下标准输入输入文件结束符为Ctrl+z，Linux为Ctrl+d。

cin.get(char var)如果成功返回的是cin对象，因此可以支持链式操作，如cin.get(b).get(c)。

cin.get(字符数组名，接收长度，结束符)
其中结束符意味着遇到该符号结束字符串读取,默认为enter，读取的字符个数最多为（长度 - 1），因为最后一个为'\0'。要注意的是，cin.get(字符数组名，接收长度，结束符)操作遇到结束符停止读取，
但并不会将结束符从缓冲区丢弃。

cin.get()会读取换行 空格

（3）cin.getline()
其用法与cin.get(字符数组名，接收长度，结束符)极为类似。cin.get()当输入的字符串超长时，不会引起cin函数的错误，后面若有cin操作，会继续执行，只是直接从缓冲区中取数据。
但是cin.getline()当输入超长时，会引起cin函数的错误，后面的cin操作将不再执行。如下代码：

istream& getline(char* s, streamsize count); //默认以换行符结束
istream& getline(char* s, streamsize count, char delim);

cin.get()每次读取一整行并把由Enter键生成的换行符留在输入队列中，然而cin.getline()每次读取一整行并把由Enter键生成的换行符抛弃
注意，cin.getline() 与 cin.get() 的区别是，cin.getline() 不会将行结束符（如换行符）残留在输入缓冲区中。

（4）getline()
同样，此处结束符为可选参数（默认依然为enter）。然而，getline()与前面的诸多存在的差别在于，它string库函数下，而非前面的istream流，所有调用前要在前面加入#include<string>。
与之对应这一方法读入时第二个参数为string类型，而不再是char*，要注意区别。另外，该方法也不是遇到空白字符(tab, space, enter(当结束符不是默认enter时))就结束输入的，且会丢弃
最后一个换行符。

istream& getline ( istream& is, string& str);						//默认以换行符\n分隔行
istream& getline ( istream& is, string& str, char delim);

getline() 利用 cin 可以从标准输入设备键盘读取一行，当遇到如下三种情况会结束读操作：
（1）文件结束；
（2）遇到行分隔符；
（3）输入达到最大限度。

注意，getline() 遇到结束符时，会将结束符一并读入指定的 string 中，再将结束符替换为空字符。因此，进行从键盘读取一行字符时，建议使用 getline。
但是，最好还是要进行标准输入的安全检查，提高程序容错能力。

cin.getline() 与 getline() 类似，但是因为 cin.getline() 的输出是char*，getline() 的输出是 string，所以 cin.getline() 属于 istream 流，而 getline() 属于 string 流，
二者是不一样的函数。

















